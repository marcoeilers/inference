domain String {
  
  function strLen(id: Int): Int
  
  function strConcat(l: Int, r: Int): Int
  
  axiom {
    (forall l: Int, r: Int :: { strLen(strConcat(l, r)) } strLen(strConcat(l, r)) == strLen(l) + strLen(r))
  }
  
  axiom {
    (forall str: Int :: { strLen(str) } 0 <= strLen(str))
  }
}
domain Types {
  
  
}
domain ShStruct2[T0, T1] {
  
  function ShStructrev0of2(v0: T0): ShStruct2[T0, T1]
  
  function ShStructrev1of2(v1: T1): ShStruct2[T0, T1]
  
  function ShStructget0of2(x: ShStruct2[T0, T1]): T0
  
  function ShStructget1of2(x: ShStruct2[T0, T1]): T1
  
  axiom {
    (forall x: ShStruct2[T0, T1], y: ShStruct2[T0, T1] :: { (eq(x, y): Bool) } (eq(x, y): Bool) == ((ShStructget0of2(x): T0) == (ShStructget0of2(y): T0) && (ShStructget1of2(x): T1) == (ShStructget1of2(y): T1)))
  }
  
  axiom {
    (forall x: ShStruct2[T0, T1] :: { (ShStructget0of2(x): T0) } (ShStructrev0of2((ShStructget0of2(x): T0)): ShStruct2[T0, T1]) == x)
  }
  
  axiom {
    (forall x: ShStruct2[T0, T1] :: { (ShStructget1of2(x): T1) } (ShStructrev1of2((ShStructget1of2(x): T1)): ShStruct2[T0, T1]) == x)
  }
}
domain Equality[T] {
  
  function eq(l: T, r: T): Bool
  
  axiom {
    (forall l: T, r: T :: { (eq(l, r): Bool) } (eq(l, r): Bool) == (l == r))
  }
}
domain Tuple2[T0, T1] {
  
  function tuple2(t0: T0, t1: T1): Tuple2[T0, T1]
  
  function get0of2(p: Tuple2[T0, T1]): T0
  
  function get1of2(p: Tuple2[T0, T1]): T1
  
  axiom getter_over_tuple2 {
    (forall t0: T0, t1: T1 :: { (tuple2(t0, t1): Tuple2[T0, T1]) } (get0of2((tuple2(t0, t1): Tuple2[T0, T1])): T0) == t0 && (get1of2((tuple2(t0, t1): Tuple2[T0, T1])): T1) == t1)
  }
  
  axiom tuple2_over_getter {
    (forall p: Tuple2[T0, T1] :: { (get0of2(p): T0) } { (get1of2(p): T1) } (tuple2((get0of2(p): T0), (get1of2(p): T1)): Tuple2[T0, T1]) == p)
  }
}
domain BoolWellFoundedOrder {
  
  axiom bool_ax_dec {
    (decreasing(false, true): Bool)
  }
  
  axiom bool_ax_bound {
    (forall bool1: Bool :: { (bounded(bool1): Bool) } (bounded(bool1): Bool))
  }
}
domain IntWellFoundedOrder {
  
  axiom integer_ax_dec {
    (forall int1: Int, int2: Int :: { (decreasing(int1, int2): Bool) } int1 < int2 ==> (decreasing(int1, int2): Bool))
  }
  
  axiom integer_ax_bound {
    (forall int1: Int :: { (bounded(int1): Bool) } int1 >= 0 ==> (bounded(int1): Bool))
  }
}
domain MuliSetWellFoundedOrder[S] {
  
  axiom multiset_ax_dec {
    (forall mSet1: Multiset[S], mSet2: Multiset[S] :: { (decreasing(mSet1, mSet2): Bool) } |mSet1| < |mSet2| ==> (decreasing(mSet1, mSet2): Bool))
  }
  
  axiom multiset_ax_bound {
    (forall mSet1: Multiset[S] :: { (bounded(mSet1): Bool) } (bounded(mSet1): Bool))
  }
}
domain PredicateInstancesWellFoundedOrder {
  
  axiom predicate_instances_ax_dec {
    (forall l1: PredicateInstance, l2: PredicateInstance :: { nestedPredicates(l1, l2) } (decreasing(l1, l2): Bool) == nestedPredicates(l1, l2))
  }
  
  axiom predicate_instances_ax_bound {
    (forall l1: PredicateInstance :: { (bounded(l1): Bool) } (bounded(l1): Bool))
  }
}
domain RationalWellFoundedOrder {
  
  axiom rational_ax_dec {
    (forall int1: Perm, int2: Perm :: { (decreasing(int1, int2): Bool) } int1 <= int2 - 1 / 1 ==> (decreasing(int1, int2): Bool))
  }
  
  axiom rational_ax_bound {
    (forall int1: Perm :: { (bounded(int1): Bool) } int1 >= 0 / 1 ==> (bounded(int1): Bool))
  }
}
domain RefWellFoundedOrder {
  
  axiom ref_ax_dec {
    (forall ref1: Ref :: { (decreasing(null, ref1): Bool) } ref1 != null ==> (decreasing(null, ref1): Bool))
  }
  
  axiom ref_ax_bound {
    (forall ref1: Ref :: { (bounded(ref1): Bool) } (bounded(ref1): Bool))
  }
}
domain SeqWellFoundedOrder[S] {
  
  axiom seq_ax_dec {
    (forall seq1: Seq[S], seq2: Seq[S] :: { (decreasing(seq1, seq2): Bool) } |seq1| < |seq2| ==> (decreasing(seq1, seq2): Bool))
  }
  
  axiom seq_ax_bound {
    (forall seq1: Seq[S] :: { (bounded(seq1): Bool) } |seq1| >= 0 ==> (bounded(seq1): Bool))
  }
}
domain SetWellFoundedOrder[S] {
  
  axiom set_ax_dec {
    (forall set1: Set[S], set2: Set[S] :: { (decreasing(set1, set2): Bool) } |set1| < |set2| ==> (decreasing(set1, set2): Bool))
  }
  
  axiom set_ax_bound {
    (forall set1: Set[S] :: { (bounded(set1): Bool) } (bounded(set1): Bool))
  }
}
domain WellFoundedOrder[T] {
  
  function decreasing(arg1: T, arg2: T): Bool
  
  function bounded(arg1: T): Bool
}
domain PredicateInstancesNestedRelation {
  
  function nestedPredicates(l1: PredicateInstance, l2: PredicateInstance): Bool
  
  axiom nestedTrans {
    (forall l1: PredicateInstance, l2: PredicateInstance, l3: PredicateInstance :: { nestedPredicates(l1, l2),nestedPredicates(l2, l3) } nestedPredicates(l1, l2) && nestedPredicates(l2, l3) ==> nestedPredicates(l1, l3))
  }
  
  axiom nestedReflex {
    (forall l1: PredicateInstance :: !nestedPredicates(l1, l1))
  }
}
domain PredicateInstance {
  
  
}
field val$_Int: Int
function strSlice(s: Int, l: Int, h: Int): Int
  requires 0 <= l
  requires l <= h
  requires h <= strLen(s)
  ensures strLen(result) == h - l
// decreases _
function shStructDefault_$valA_Intint$$$_S_$$$_vulA_Intint$$$_S_$$$$(): ShStruct2[Ref, Ref]
  ensures true && (ShStructget0of2(result): Ref) == null && (ShStructget1of2(result): Ref) == null

field myField: Ref
field myField2: Int

method marco_bda1d7d_F(x_V0: ShStruct2[Ref, Ref])
  //requires acc(urghy.myField)
  //requires urghy == ShStructget1of2(x_V0)
  //requires true && acc((ShStructget0of2(x_V0): Ref).val$_Int, write) && acc((ShStructget1of2(x_V0): Ref).val$_Int, write)
  //requires (ShStructget1of2(x_V0): Ref).val$_Int == 12
  //ensures acc((ShStructget1of2(x_V0): Ref).val$_Int, write) && (ShStructget1of2(x_V0): Ref).val$_Int == 13
{
  
  // decl x_V0_CN0: *mell_bda1d7d_T°
  var x_V0_CN0: ShStruct2[Ref, Ref]
  
  
  
  // init x_V0_CN0
  inhale x_V0_CN0 == shStructDefault_$valA_Intint$$$_S_$$$_vulA_Intint$$$_S_$$$$()
  
  // x_V0_CN0 = x_V0
  x_V0_CN0 := x_V0
  
  // decl 
  
  // *x_V0_CN0.vulA = *x_V0_CN0.vulA + 1
  (ShStructget1of2(x_V0_CN0): Ref).val$_Int := (ShStructget1of2(x_V0_CN0): Ref).val$_Int + 1
  label returnLabel
}
method client_bda1d7d_F()
{
  
  // decl 
  
  
  
  // decl N0: *mell_bda1d7d_T°, m_V0: *mell_bda1d7d_T°
  var m_V0: ShStruct2[Ref, Ref]
  var N0: ShStruct2[Ref, Ref]
  
  // N0 = new(mell_bda1d7d_T{1, 12})
  var fn$$0: ShStruct2[Ref, Ref]
  inhale true && acc((ShStructget0of2(fn$$0): Ref).val$_Int, write) && acc((ShStructget1of2(fn$$0): Ref).val$_Int, write) && (true && (ShStructget0of2(fn$$0): Ref).val$_Int == (get0of2((tuple2(1, 12): Tuple2[Int, Int])): Int) && (ShStructget1of2(fn$$0): Ref).val$_Int == (get1of2((tuple2(1, 12): Tuple2[Int, Int])): Int))
  N0 := fn$$0
  
  // init m_V0
  inhale m_V0 == shStructDefault_$valA_Intint$$$_S_$$$_vulA_Intint$$$_S_$$$$()
  
  // m_V0 = N0
  m_V0 := N0
  
  // marco_bda1d7d_F(ShStructget1of2(m_V0), m_V0)
  marco_bda1d7d_F(m_V0)
  label returnLabel
}
method $IMPORTS_bda1d7d_bda1d7d()
{
  
  // decl 
  
  
  label returnLabel
}
// decreases 
method $INIT_bda1d7d_39314844()
{
  
  // decl 
  
  
  label returnLabel
}
